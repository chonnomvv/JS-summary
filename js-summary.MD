Data type
- 자바스크립트의 모드 ‘값’은 데이터 타입을 갖는다.
- 자바스크립트는 7개의 데이터 타입을 지원한다. 
- 크게 원시타입과 객체 타입으로 분류한다.
- 원시타입 
    - 숫자타입(Number)
    - 문자열(String)
    - 불리언타입(Boolean)
    - undefined : 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값
    - null 타입: 값이 없다는 것을 의도적으로 명시하기 위해
    - Symbol 타입
- 객체타입
    - 객체, 함수, 배열 등

- 값의 표현 방법
    - 리터럴 표기법
    - 표현식 
        - 표현식은 평가되어 하나의 값을 만듦. 즉 하나의 값으로 평가될 수 있는 문

- 동적 타입 언어와 정적 타입 언어
- 정적 타입 언어는 변수의 타입을 변경할 수 없다.  컴파일 시점에 타입 체크를 수행.
- 자바스크립트는 변수 선언시 타입을 선언하지 않음.

Literal
- 소스 코드 안에서 직접 만들어 낸 고정된 값 자체
- 사람이 이해할 수 있는 표기법으로 값의 생성을 자바스크립트 엔진에게 명령하는 것
- 리터럴은 그 자체로 표현식이며 표현식의 일부로서 다른 값을 생성
    - 10 + 20 // 리터럴 10과 리터럴 20은 표현식의 일부
- 자바스크립트 엔진과 개발자 간의 약속. 

Expression
- 값을 다양한 방법으로 생성할 수 있다. 여기서 다양한 방법이란 바로 표현식
- 리터럴, 식별자(함수명, 변수명),연산자, 함수 호출 등의 조합!!
- 표현식은 평가되어 하나의 값을 만든다.
- 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/메서드 호출 표현식

Primitivie type & Object type
- 원시 타입은 변경이 불가능한 값
- 객체 타입은 변경 가능한 값
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달.
    - 값에 의한 전달(Pass by value)
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달.
    - 참조에 의한 전달(Pass by reference)
- 원시값은 변경 불가능. 이는 값의 신뢰성을 보장


Function Definition
- 입력(input)을 받아서 출력(output)을 내보내는 일련의 과정
- 프로그래밍 언어의 함수는 일련의 과정을 문들로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것. 이때 입력을 전달받는 변수를 매개변수, 입력을 인수, 출력을 반환값이라고 한다. 
- 함수를 정의하는 방법은 4가지가 있다.
    - 1. 함수 선언문
        - 함수명 생력할 수 없다.
    - 2. 함수 표현식
        - 함수는 일급 객체이고 따라서 함수를 값처럼 이용할 수 있다. 
        - 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수표현식이라고 한다.
    - 3. Function 생성자 함수
        - 자바스크립트가 기본으로 제공하는 빌트인 함수인 Function 생성자 함수는 매개변수 목록과 함수 몸체를 문자열로 전달 받는다.
        - 일반적이지 않고 바람직하지 않는 방법.
    - 4. 화살표 함수
        - ES6에서 새롭게 도입된 화살표 함수. 간략한 방법으로 함수를 선언 할 수 있다.
        - 기존 함수와 this바인딩 방식이 다르고 prototype 프로퍼티가 없고 arguments객체를 생성하지 않는다. 

Scope
- 변수는 자신이 선언된 위치에 의해 자신이 유요한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정되는데 이 범위를 scope라고 한다. 
- 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정한다. 즉 스코프란 자바스크립트 엔진이 참조할 변수를 검색할 때 사용하는 규칙.
- 전역과 지역.
- 스코프체인 - 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

 Lexical scope = 정적스코프
- 함수를 어디서 호출했는지? vs 함수를 어디서 정의했는지!
- 자바스크립트는 렉시컬 스코프를 따른다. 즉 함수를 어디서 호출했는지가 아니고 어디에 정의했는지에 따라 스코프를 결정한다. (정적스코프)

전역 변수의 문제점
- 선언하지 않은 변수에 값을 할당하면 자바스크립트 엔진은 아무런 에러없이 암묵적으로 전역변수를 선언하고 값을 할당한다.
- 자바스크립트 파일은 여러개로 분리되어 있다해도 하나의 전역 스코프를 공유한다. 다시 말해 자바스크립트는 파일마다 독립적인 파일 스코프를 갖지 않는다. 
- 지역 변수의 생명 주기
    - 함수 내부에서 선언된 지역변수는 함수가 호출되어 실행되는 동안에만 유효
    - 전역변수는 애플리케이션이 종료하기 전까지 계속 유효.
- 1. 암묵적 결합
    - 변수의 유효 범위가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아짐
- 2. 긴 생명 주기
    - 상태를 변경할 시간도 길고 상태를 변경할 기회도 많다. 메모리 리소스도 오랜 기간 소비
- 3. 스코프 체인상 종점에 존재
    - 전역 변수의 검색 속도가 가장 느리다.
- 4. 네임 스페이스 오염
    - 파일이 분리 되어 있어도 전역 스코프를 공유

var 키워드로 선언한 변수의 문제점
- ES5까지 변수를 선언할 수 있는 유일한 방법 var
- 1. 변수 중복 선언 허용
- 2. 함수 레벨 스코프
    - 함수 외부에서 선언한 변수는 모두 전역변수
- 3. 변수 호이스팅
    - var키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작. var키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 

Constructor Function
- 생성자 함수란 new 연산자와 함께 호출하여 객체를 생성하는 함수.
- 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.
- Object, String, Number, Boolean, Function, Array, Date, RegExp등의 빌트인 생성자 함수를 제공.
- 객체 리터럴에 의한 객체 생성방식의 문제점
    - 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적.
- 생성자 함수에 의한 객체 생성 방식의 장점
    - 마치 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 

This
- this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수.
- this가 가리키는 객체는 함수 호출 방식에 따라 결정
    - 일반 함수로서 호출 : 전역 객체
    - 메소드로서 호출: 메소드를 호출한 객체
    - 생성자 함수로서 호출: 생성자 함수가 생성할 인스턴스
- this에 바인딩될 객체는 함수의 호출방식에 따라 결정됨.(동적으로)
- Function.prototpye.apply/call/bind : 인수로 this와 인수 리스트를 전달받아 함수를 호출한다. 

DOM
- 브라우저의 렌더링 엔진은 웹 문서를 로드한 후, 파싱하여 웹 문서를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데 이를 DOM이라고 한다. 즉 모든 요소와 요소의 어트리뷰트, 텍스트를 각각의 객체로 만들고 이들 객체를 부자 관계로 표현할 수 있는 트리 구조로 구성한 것이 DOM이다.
- Document Object Model
- Dom tree는 브라우저가 HTML 문서를 로드한 후 파싱하여 생성하는 모델을 의미.
- DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document객체의 자식. 
- 문서노드(시작점) -  요소노드 - 어트리뷰트 노드 - 텍스트 노드(최종단)
- Dom을 통해 웹페이지를 조작하려면 다음과 같은 단계가 필요
    - 조작하고자 하는 요소를 선택 또는 탐색
    - 선택된 요소의 콘텐츠 또는 어트리뷰트를 조작

Event Delegation
- li요소가 100개라면 100개의 이벤트 핸들러를 바인딩해여야한다.
- 동적으로 li 요소가 추가되는 경우, 아직 추가되지 않은 요소는 DOM에 존재하지 않으므로 이벤트 핸들러를 바인딩 할 수 없다. 
- 이벤트위임은 다수의 자식 요소에 각각 이벤트 핸들러를 바인딩하는 대신 하나의 부모 요소에 이벤트 핸들러를 바인딩하는 방법.
- 이는 이벤트가 이벤트 흐름에 의해 이벤트를 발생시킨 요소의 부모 요소에도 영향을 미치기 때문에 가능(버블링)


Promise
- 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 전통적인 콜백 패턴은 가독성이 나쁘고 비동기 처리 중 발생핸 에러의 예외 처리가 곤란하며 여러 개의 비동기 처리 로직을 한꺼번에 처리하는 것도 한계가 있다. 이에ES6에서 도입한 비동기 처리를 위한 또 다른 패턴으로 프로미스를 도입!
- Promise 생성자 함수를 통해 인스턴스화.
- Promise생성자 함수는 비동기 작업을 수행할 콜백 함수를 인자로 전달받는데 이 콜백 함수는 resolve, reject함수를 인자로 전달 받는다.
- 프로미스의 후속 처리 메소드
    - then : then 메소드는 두 개의 콜백 함수를 인자로 전달 받는다. 첫 번째 콜백 함수는 성공시 호출되고(fulfilled, resolve) 두 번째 함수는 실패(rejected, reject)시 호출
    - then 메소드는 Promise를 반환한다.
    - catch: 예외가 발생하면 호출. Promise를 반환
- 프로미스 체이닝 
    - then 메소드가 promise객체를 반환하도록 하면 여러개의 프로미스를 연결. 이로써 콜백 헬을 해결.
- 프로미스의 정적 메소드
    - resolve, reject
    - all
    - race

Super
- super는 ES6에서 도입된 클래스에서 부모 클래스를 참조할 때 또는 부모 클래스의 생성자를 호출할 때 사용.

